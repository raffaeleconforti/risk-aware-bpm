package org.yawlfoundation.yawl.sensors.language;

import org.jdom.Element;
import org.yawlfoundation.yawl.util.JDOMUtil;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;

public class YExpression{
	
	private String currToken;
	private StringTokenizer st;
	public static final String CONTAINS = "}";
	public static final String ISCONTAINED = "{";
	public static final String DOT = ".";
	public static final String PARTA = "(";
	public static final String PARTC = ")";
	public static final String PARQA = "[";
	public static final String PARQC = "]";
	public static final String SUM = "+";
	public static final String SUB = "-";
	public static final String MULTIPLY = "*";
	public static final String DIVIDE = "/";
	public static final String EXP = "^";
	public static final String MOD = "%";
	public static final String AND = "&";
	public static final String OR = "|";
	public static final String NOT = "!";
	public static final String MINOR = "<";
	public static final String MINOREQUAL = "<=";
	public static final String EQUAL = "==";
	public static final String SINGLEEQUAL = "=";
	public static final String NOTEQUAL = "!=";
	public static final String GREATEREQUAL = ">=";
	public static final String GREATER = ">";
	public static final String TRUE = "true";
	public static final String FALSE = "false";
	private final DateFormat originalDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	private final DateFormat dateFormat = new SimpleDateFormat("yyyy:MM:dd HH:mm:ss");
	
	public static void main(String[] args) {
//			long t = System.nanoTime();
//			Boolean de = (Boolean) test.evaluate("${!(22.566599666231934>=11.131371330504214)&&true||!((18.691966863970457-13.55899087421274)>96.63484842838095)||(37.43423982977448-11.205176396524186-21.03830884583028)<=24.161053263337738||!(78.0625838587198!=24.70717446971986)&&!(96.23631193700545==(60.76627268763356+56.89225530661105-(15.467437212755442/(16.22236537993478+64.57705495475942-84.40667520065386)*61.97728003852264*90.82751704172894)*39.86146958623571*80.69039632757516-31.53312647765918))&&36.61859436309779>=75.44243327125905&&false||40.67303494216823==4.164161070703698||!(true)||!(false)&&!((70.81869253742109-(74.67235493968514/43.888638091868316/78.49642420602319*16.764249895215976+12.80595266926844*4.186336900667776+94.57362660441791*(26.17970797407816/27.731270509552697)-88.8033616927241)*93.55465386298451*21.859465683937916*4.495729031044437-31.876412635340934*5.873660202762398*(((27.47172163852385*10.431049736891385/78.62994830284784+55.35771460553329*66.52231036841724-35.43695590896658/74.83273815208321-7.6189019653680194)/(21.91248298195678*90.85716467788941/(47.08769129534751-60.73239468390944/((17.801891852108163-68.88804486997681*7.730180693785149/(42.20034131728339/35.79259982979968+26.13010532481376+30.746559389688187*1.5338704124227664*45.581236849422666*9.428348323633106-94.63123682637011/88.26200176908802-85.81127218300139)*70.47124892561504)-(19.299715416017648/70.5576860981297/50.56677826731798-4.076225983911785/(5.276391981341266-78.96401313276495))*51.82027503148202-27.992236690472318-42.98708600759561*40.39834247644647-(94.38943975748779*51.961954800089835/57.67854386763126/47.7695401663029-80.61569644964949+65.6339891778129-(55.87172811931729)-(90.3563631283257-(93.46711585834021*(((33.33586858695649/(24.69382011316258*((80.52583706139539-69.40541459669012)*40.03260841143109*(23.024246944120353*(6.419894920550329)*22.64421432793402/48.78358696249664/9.483012890829823*47.57525197302769+39.35590321819332)*16.548867633222073*(9.101804576833993*(82.25377106732881-66.41792669919569*(32.299604198416596-97.33723734950107)-41.31698103513452*41.04954124455419/23.751350017542105/36.77763270873518-78.1365633649724)-46.42010833369409)*42.27181217707662*71.89096090891927)*71.11856088604401-90.24238957252994*(((76.0793065603345*70.91577779517486-37.79977543429132-37.571018978037905)))*76.0988156689928*51.91083027448603*86.56303646935164)-97.42097153849282-9.992177691823267/75.94959464616498+60.389089684448+27.12942361500432-7.922665813044527-1.4666584715866127*49.21959983206615)-26.42697593009332-(87.93270199021968*14.597881986746142-(54.29847067917974/75.41312720142773/(22.39685844248528-45.43178509007307/(58.89554990614586-60.85392200205343+19.607207875507505-96.46563140959078+36.10701852001371)*34.776457619686695/49.752892922123046)/(28.26410203197609/63.833971676138404))-((16.442482227380818-38.146868125297914-28.339742969669057)/(61.374907747244364-84.4622943361246-(28.85807337219409*(84.81967437600966*29.453312088554128*57.8736616977606/80.28066229636266-80.33027917354146-74.05761930315579)-46.670034206963294/(69.8156015432837*((70.7491339569671-27.59722686274786-46.57807497904754/60.58065683784246-81.26766860346419+36.68449803329082/66.60908720858363/(36.24866378114204/(68.12729498370517*24.624257640278323/21.87623193909549))*50.606165553686466*58.56941961446235-68.22203827916378-88.94132472256237*52.02894661571741/13.726337755929574+86.80837184926227*96.87655845516784*53.320577638743174*96.8897378106335*(31.1710889423058-(28.444746971911105)*49.92126799158421+(51.63727228103924-95.73316598638321/(37.85916265249383/87.97260650929604/46.45115147379201*9.410168701140476*90.20654441976647+(65.91056037621495*(20.169971989634263*(61.80107890179464*58.5457149532403*39.44847752323367+12.08440580364062-65.46435307285525-92.29094918501276-73.6551652832675-37.138419919667044+68.13286603806347-1.1651257675519333*(96.3405324051102)/35.72654551374074-4.340961341570471*77.60359292110583+96.20599808858626+63.2131535038799*73.92893709685575*73.5937351093534+43.67407074151659/72.28927967064682*(69.79692180724825-34.50880109453981/32.53529869200257/50.69262927977458+71.07099402580879*87.30585004101302-69.76359728690811)*45.03562174815239)/99.38299022051328-77.99238973807861-4.35824653609902*0.3410634994285955-20.07269205080301-37.08411756437149/57.314530542634415*39.49887799419282*74.0600156605787*44.385422129921245/(88.24364367208524*(12.201942732472848/81.91661306351166+92.33669648278364+49.26312124254514+80.81172977403959/87.24052271508015*1.2758110240180032+23.58875987530333+41.14022239162747/32.303163566790026)-(24.42768473925765*22.424846274558984)*89.0895890657546)*92.10257535995015-64.79009172352136))-9.025234403167504+54.1587751281832-70.96190039451203-((62.15384050221644))-73.86025586478179-73.67445083516337+29.595558992581317)*((66.64726494912183*32.067357875001825/((89.8445981549196*8.053389480557904+54.34552913079587-(16.621280885520495-68.91594084858492)-87.83307253629624/53.01408562205503/60.20448368776654-82.6586383004945-57.796335264314976*83.15355084733449-18.700811472065016))-60.68273506737748*(29.271707907484434*13.568897355595277)-45.42449810665611+65.66134395059365-70.58848238580873*40.545955100011156)*5.169524137187653-99.20648589546343/42.359586005718/((61.14480935297636-81.43309099726315*((((24.446865847493747+41.845956581294196)*37.936481092713024/((52.47161138865197-72.08859393912861))+(99.78941373427435*35.96145683616451)*34.49556130354203+1.5857752793051016)*82.48518421243003-8.428202162112076)-(28.318874597968257+19.823398338191602*48.17854966500431*22.413238646880295+(30.619333766477506-44.63163236998005*37.528994425186326)*43.05628538451125+93.10004180075391*89.20060037808084/((61.03568037303086)/34.859775231205724)*((76.7435564562356)/51.75165977017835))/16.863500202501946*72.59602759362525-31.433721976973917+54.4708488041273-33.0932150897636-30.588197058148836-30.574007579350926-12.392886710853668*86.21048372955268))))*(50.93661870890688+74.34120423943182)*56.322580201185744+9.487865275790142/(86.29250550544774+40.18053399651937+28.876492657025633/15.342775308193302)*14.467554448303598/82.69611001115173+50.33634807845011+30.91140086670284))+(89.71125273950267*5.6103212862144485+97.5112708871108)/(45.95893263393419-(65.91682138679414)*(16.008949214337807+(2.071241138018798*89.15741751064559)-13.493408034519739+12.137393826602805-22.539179061669135*91.0448110634233+29.30187996131902+37.5412230096038+83.58380626015204*(82.6840284277598-(80.98242984406816-88.78065454726408*3.983888420063819-16.4785452273438+((57.42338702906354-78.62167773911601)))-(93.95388484728124/(53.505282641301356)-(85.58377438767748+57.67415115322244))-67.75604949365325-3.0170139051314826-71.83217349398451-71.2570972149011-66.63206983812047*29.230926983568438*59.25008916164626-94.33616952880668*(58.43367873143806-19.287522387002*(83.56867851446317*(((88.18483125976331/58.068095436554344)-79.37511100198365/73.10679531535364)-69.5208748263079*(90.7379875784361+71.65879502865837+27.5415289616591+94.91463072863216+83.39115875498248-84.47869509719148/45.960174767695946-90.36431664528008+92.86074495731094*23.856286938235293))+79.52035151006929-73.85567337922417/7.25469690595607*(67.66917331359537/(67.00942260050724/(33.90879651666422*59.06869277883069+26.48762720187895*11.65596830683928-(37.79461080337166/74.56647050727805+(72.50186004517475-67.47625101990353*18.832736985867726-92.20735830820328))+80.59730873481332-61.964273876463324-4.168090357104493*4.6267120333068785-42.40194758254464/61.90887758884931-(48.96256936080512*98.9792565948995-78.18526779508773/(53.63539848446742*67.92196608026242/46.0218642501659-92.1595011548324))/29.953033846794817/11.301893355734993*3.4949143799270277-32.96022870598904/9.701396376500504+18.326255526869694/3.88942957147439/11.950909757301641-61.100867885066826+(5.306955960670001/40.95326361054409))/57.33690858713034-66.27924945686689*88.25874335004856+83.15455697577991*65.89917921035958)-32.867900454400555-12.416173783569295+90.46826909446224/49.59546865969862)-99.56136685513451*18.514298899122938-10.191270596201385/36.13452311753288-47.06026819521642))*41.14618734722046)))-93.57395978777652)*(46.15233290063833/46.142552860592836-99.79854489140448-(29.60801337846527*(((15.115371741878514-(52.21621016527364-23.864225050993337)-6.546528890304049/81.59506022046595)+8.322963720104203*85.92455489273203*89.30825099282596/21.00932595483156-32.63649000475648-44.46080288285273)-6.699152807065878-98.23422801372828-57.63812896103393*((67.4916687614931/10.192726893056747+61.733367894254535+69.84827703904008-56.652849502311966*66.76341266980646*87.77779920885473/44.55971583042342-70.4305645184496-88.15747853760168*91.53658211452166))))-8.079518530919682*70.49052704640677)*5.854296737325315*63.80429453283042*40.400638273785496-26.56539193528826/76.14606379730581-(25.77615505557266-29.062468143477492)*79.31741546908016*60.78192284029127-76.83708690444301-99.31943077051659*63.23994850282511*(34.397710587914844*56.29135409691799)-42.02936684814691+8.73462783041916-(18.54422120779575/19.34611849913015)*63.7685353701158/69.04270260584067/(65.43597342951885-80.94330177599906+67.04481003611164-(9.868133152580782/29.498023102084602*(88.23702559199316-89.73106968386955)*(41.91201705583884-66.28971948742452-91.58056035874239-34.67736986972724*17.35088298907731-47.74209704207348*95.73594638106758)-42.011771595355206*1.4527633002274887*38.266414646116566)*95.34420760001892-7.0287881441665085-90.04190226690096/52.2178300989576*12.261201103569853*(83.1936293644204-(67.58407667700493-59.42606382550291)))/77.81105518751532/11.296534162993787*66.55812562778375-68.17833100876888*55.04005858355553-71.09183959364984*61.74587630069945-18.050734997794837/96.03423251038934*26.991110793475382/25.99391739167285-((61.009754419838956*4.497211525965628)))+62.33644607262359-83.31598962469292/45.86990204462922+23.98381751848809/26.38162940121571)))+84.42220361059886*68.34297695300258/3.0696826482971007-44.27356136260819-(86.91035615362719-8.908391814477978)+43.91786560860973*85.13574295349568*16.81051716686428/41.37707976170516/(25.92071066186711*50.4215061086686*61.799088118586894)*48.835314890160795-84.01521852719574-75.5289227250378+(55.30413733111802-(61.082996170055814*89.09666938735845/93.3570987369108*36.00610666765078*57.092301155248784*58.53832521874296+26.243761025517987*64.35010257033905*58.76078024601171-83.20046646020045-((52.268583637393796/43.06994254885539)/15.327996467353099-17.557874056238454-65.02766093327921)*85.43085194405326*17.591309437959033/71.06894133909391-(66.15746694765492)*97.73315556384865-51.85161453786806-((97.39950268066212)/90.438290596747)))+(67.01319341443465/27.44099942927655-(8.136712259279443-76.85016790389214-20.89603125218593*3.3338320849999548/0.41640374388437484/83.48772292198471+29.520820379826716+23.824219561339042-13.074234514776839*64.58440955381896+88.6022319120672*84.42720833608483*(46.894143417679615-19.03083668713823*(21.852022359990976+(66.65255167572408-17.278375469701224*25.406005024991874)+2.522517458757201/41.67130979721018*21.00069690885553)*54.04404591123283/(85.8627010871776))+26.348227701601388))-15.029507896247008))-(39.846562653081484-2.6110977956690706*43.950959222489416*76.31395573506319-15.523035341983249*37.53595878042755-12.176494245915004-57.370477708179216-(71.05983430311629*16.696343360159936)/22.42211546757582-(73.01644324294398/70.51214512611969+73.4529841298404*96.1198089120025*52.91506862987123*65.39264588869639)-86.73419463530814+28.362287388631923/87.96900925378691-5.4473042655254105*38.155037967479686)+4.800570361679702*14.337752422607341+74.63288612203075)*6.674246529231953-49.3428146818777-67.25261626909811-20.725698670089244/27.680139403843395-7.537872974196558/(45.29714218106285/74.25398703216982*92.057529410349+92.5864433286855)+3.692617777510254/(38.5872892181614)/74.2832231891654*50.23041291917506/(21.74382395449934)*83.52814213313154*71.27785491822065*43.8083305286258)-70.15756991897325-63.07812438971514/(13.834985874743278+(43.80131076246225/62.341955081120105*72.4943805491679)/16.490598600973982-94.9051288248934*37.367326583265246-(44.788786855819716/((34.05456865820514/42.02558926308424-52.738841614316165-50.27860868735458/36.18194414951892+2.480870745636654-77.9830623361415-71.28035691184841*97.35341463302079))-59.61526108724888*45.379919561298344*59.51050717917112-70.80502688081572)*40.31421209829137-10.337912616616563*57.946783776010335-45.90535944840269-(37.58116270463029*88.51982110415021+11.165689047147398)*64.14220154916568+(((39.19671291308893)*79.7110651130257-70.18175857801438-44.407071990104676*95.59912547598235-83.76223607867689*(21.717108617811064*68.36384672857045+50.69980493149264/25.095006572302005*29.610860241771555))*38.93986425453141+23.66470866450604*(((88.28025997904079*86.43069918502519)-63.72908650678348)))-(34.27242344693623-56.36660611831338*63.73957851734973-95.40713148250634)/41.19592965864359)-(55.50664597828791/(87.88705811871348-(72.22847306740783-32.687438962375225/61.849259691677325)-9.825476775476016)-11.854936109887104+91.60679854324485)-(63.62707765837197-60.071733708435495*2.191472542215245/20.788623450593025/21.05462522510403)-27.075047279540797/56.38461162984837/19.475165269767626*34.39347902484508+87.681682247256/54.165382613342-34.909765720860456*(31.155058231645317*13.67896526501532)-33.36645340596878+(71.63586538559204*92.7457013522948*(30.004481146954664)*35.04230061782797-(14.032175269670033-81.03165247103864*58.17435942317996*93.3262145263768)-33.142702701702774*82.72169502774005+0.20426355554566955*14.714682296587878*93.07027823051008/(12.184501737640074+12.439293713903032)+64.29274122468536/4.701531528790525*((23.706706903351925)-42.760817535109595*93.50091717587176-96.13325344172655+84.8725172490848*11.318344954783853-13.830592864666402*6.143761321614383*92.05953714380047-6.12287256143047*26.37837565086333*4.620249774154961/11.990370142824336)*(10.002060528563794)*(2.316291843815943-(61.439275649441235+99.68249894609963/57.842374300454814/86.97126351583731/42.118718534997655/29.157922236999887-66.51852802231775/20.447129010426245+66.26421232469639)/(9.723664217062321*52.37303376547755*(62.26820510906684/(51.4003615224915-22.748136960439446+90.4987000590828+31.965138999536393+13.51805593669193*3.4548121268104914*(2.8655356750889815*14.095257052051958-36.23982910542606-(78.11611590058126/26.251007671447603*(80.12931472865624)-19.49588415995497)-36.13758494706366*84.02304388237505*92.77765431618073/10.338801821426957+58.69990804881876/5.360375583794474+95.92904985958015+78.40180985112018*(7.843168849121119+60.500399122903445*83.64444006170004*62.630142642405985*43.82966078120493-(36.322161775871145+98.03714275046573-37.46473660883199/11.776203358923132)-57.67906671399772*(93.32002352675282-4.106349649443819))*((74.13153643735284/63.00687123213922-(10.745273753709983*59.22435118237731)-15.838962389082345)+18.009580729789942-14.387576172794358/(4.469885188620248-81.25586399341704-3.0117756515691707-92.47475877754505-60.645257761638305+48.30054121343162+76.60488870324735)*56.63784785237533-7.828924141375182/69.60134387365102)+67.9154050714927-((91.8834993081954*0.42497610311406087*(48.26559098985008)*63.6082850771613*86.94765874206098-36.68583986093439)+(22.188864421082176/(12.60402480310342)-64.62555124748211+30.253512028067032/39.46472000827824-23.34789096442028*1.5838208451284363*(1.511931992715121+49.5292557216638-52.392146023561246-40.7635410737003-6.967261278884518+3.2140567155163446/(26.673800808192617)*77.19576956075393-31.288307501679757*9.574748405085142*3.79198859742812*36.30517340034508/10.85253990718421)/12.260365419230856-51.50114044944972)-93.41630869394389))+20.889601621353815)+88.1765310187305*82.85286901211336-15.611727396763131-69.38062270830602+(14.546309382204093-(52.95381023891863/66.51228959524232-59.043393928127195/90.71998844721725))-18.86366240180465-57.7458161589815)/71.92009444638923*(24.738827280870034+15.88227305463744+53.1208259903446-12.214522153205642-40.57291953301439)*42.325108377706975)*16.161726464929227-0.5705385465528456/36.64218159009912/96.01929114389482*59.27515072336658*50.97443478134267/69.49189380396406))*66.03671113313351-(99.61167180708054-71.93038293898306-16.7712031074162-(46.84658732660025*43.50944047052896+(58.78400137100067)*58.418275305072996/(35.55740874761949-94.79511020272304/47.35592721255877/11.77605802821111*63.1680432013954-77.45163648102857*41.82012022244955-29.858205531041403/((21.081262613495568-91.96994765760154*53.03721858610761)/(48.12371242419539*98.40762544889937/57.890594513146254)-(20.240641121643755+7.694888962642943+60.09929378983302*45.05346238540577-(91.3462870047549-80.00525889786923+(17.938218447897615+67.00291692019209/64.58884786989081))*95.4884290734655*58.780441359858735+30.372617086558762/(24.47954113466221/7.09606647452492*2.226493105324967*(68.49009760720124-49.13321247521477-8.364805722725755*51.42857648757222-26.57578140612954-12.60970601829905*(69.82880236749389))+3.104962079787499)*90.26755112628338)+23.796995829093238)))))-47.596476393097454+57.82496489803124)/77.84506130834666)+36.1803701527453-76.51123836399303*26.982558211365358-51.76604395577944*59.49632483998498-66.76908233558308*99.50550517695652-85.28668394039379/(((20.79538271629534*(81.10177533118703/14.640752541428647+84.56938998367708*(61.69633641466212/89.58576431512078-61.475853389856674+31.854158788795782/62.66645948027616-78.58299079879622)-49.10140103467936-85.12401925388298-37.92443110437683*90.23034468129114))/77.84417510072305*87.4349876831511/61.569999454658685+78.45753692840239*39.65779786878345)/91.98460605703379*29.472968953165967*76.20850106484573+51.41580637808727/(87.05322951142435-59.94045316307872-57.89147592754777+76.84950134491726-1.239475340401519/89.95285320852074-37.80093344289431))-89.72844746069487*78.0009534665552)/(36.61320089889736*40.29286020564082*((25.363416712615972-73.5582628636817+34.170473182980054-71.33552070529443-66.38623192631078)*(23.266992955449737/50.234320709679224/46.07491108532046-83.55835753833216*25.52643687093944))*26.123629501216417-43.66874502890239*70.62825899385669/78.58905856056725+(15.642164512431723-38.0908715593898/15.23135115525328*49.53656479235524-50.63265788275147)*(8.630903092205621)-(76.62434368326159)))-54.0320910573041/75.66968133619471-63.214221811300774+43.95798013863504*4.373118874101567)-42.5614182554663)*40.41279243132221+93.00979075570793-35.52771576835724)-34.3080703598454)>66.11678117460417)||!(true)||!(65.10363995955007==61.07170443259806)||!(true)&&!(false)||33.835036776544705>=85.56102246212015&&true&&(52.785088622958185+5.577387191025707/((6.851494619538256/70.76401212124274*74.9745573740038*34.79224345445591+92.74125796287632-18.469790833279564-12.18917119196834))/92.19810918182927/53.51575461681367-2.3670119287563574-87.44503475961461-31.05441645983721+37.73664068472796-17.593676823548854*48.336178205500005+43.149192639398926/87.65967777152743+(57.5177298489166*35.30665063190321*((67.18145337599759-91.04538948090341+62.87398987907513-62.14652025425277*40.90393353130401)*88.39790421265782))/93.41792423443755)<=61.307035798884776&&true||!((63.65681282770582)<=81.39537952890326)&&!(false)&&!(23.05019191685467>=(46.70143623421508-69.75519683083452*78.15214554905012*61.6926182701831/(23.645470429320326*(41.17634634475606-99.03378999645716/5.193556795457521*(11.413281546700949*79.27201737934375-0.4033159843987555+39.17440179859092*(34.49782424757309*13.47259890151391+93.29182660312183)+25.594506658624038/((64.12731680864142+55.166840298748866*22.48057611104455-(64.94915391198035*0.8691795244562428-(48.04288595879335*12.30629881109454)*80.52546079892711-52.36146216070925-(6.578196481943488+(31.56482421907738-67.66660302969764/(((73.54547484389221*53.936305938071236+76.84993688571593-86.1061323924024+((((96.45416857414965-74.81978743143056+79.73027327875418*93.4068423888919*53.850835362044926)/50.57610828141223/(75.59443782690278-88.91807246424419*71.87229051951103*95.20716489820354-67.78527417865854-64.42398581946777*53.71113491490301*23.160426180750548-((42.52608695338319-((34.083356341806784-71.6652066059685*85.93901053009169*46.904152096718335)*12.779553908490215*75.70070206350948)-10.129029934299794-58.14606311548821+62.43090753633933-40.95406204194577/79.38027880621624+52.38624134332558+74.04250960986101/20.76865893435935)-11.149649465540957-(1.8499248136645385*(18.51402622702829-65.9154702682478*21.5633484643865+6.928620451663314-31.043365576359406)/32.08923194688246+39.34893311554566-8.796719052944823-75.90634291277027)-15.891035091027305)*76.5404825039949*83.08009852137496-62.6057937009764-76.1408848239562-13.160587989567407)-9.022100966797863*17.126646255747822))/31.380698116047313*(34.31490036153506/36.93718833709006*91.07571350908883+42.21241315114111+82.1569637044222/44.17183706915506*47.82355660970882+21.29758414717653-40.73066559855199-91.05587108811241/70.92199275491224-35.44032219355169*94.82829085695673*(61.443172362482045+25.776957761287722*33.05824721186055*(19.484160416441487*23.120992732540348+81.0949836119281)*17.779535475235264-37.483826880569204*98.65447343321998-1.5152798169054016*21.349335531014468)+70.96148431944239*61.50222934354414*25.52450309881632)*48.34139182255737*83.21249755057714*91.03166326128755+47.49866166127481-61.870238442399184/41.43211057666092*73.74294966389402*18.377080580561746/78.11519067723344-(67.4976207098853/98.27876252299933)*71.15998261121074/21.463376574741623-99.37796405498658*46.49039429163931*62.02331974155562/61.63106556888508+((22.467808841079908)+21.45931827066643+38.791025967287354*65.50403501885465*18.52992933813472-12.433568730048439-84.30113373744008/27.617981057291107-25.324901234798602*94.9952949237855*84.95468087611076)-22.975707098514174)*2.2497200048823274/(64.55077956051005*63.912680707657344/63.44811530528326+47.14251891804955-61.63157095859879*5.187962026901383*68.17154692520461/69.79462835832078*14.276654506206409*45.810368132667534*16.234034200850424))/(61.501040005777206)*19.149664468413675/(44.50268273600221*(18.15509092583816-71.69016761476955)-18.897449821218927*83.91513186333609/29.283310056535818-4.1548274320098555)-13.6207841621522-29.1473119177436*60.52018202246827-25.75490132698588)-84.96995041385615+5.17577995568873-77.08586081574344*45.35263925249984)*22.89001863256922)+71.0476315682008)-97.41012410485989-45.56950586594719-19.716227339920255*73.96073255718424-91.19365672984769))+52.81496323731307-(81.83882732117357)*(64.17432994531971))/16.10359624631288+87.92062692649476)+94.7856327389584)*58.65149983862873)-66.11381302108572+58.06058541774568-13.472043497787645*92.56991413552504-55.644815770241074+((81.40717452241275*29.199548573758015-36.03470357786198)-(13.281487318573726*30.656123828345894*90.79879850670446-(57.39364096920699/26.041134695978286))/21.79041992614421)/26.180692369506954*(59.89814453279436*11.91848985012227-((47.9074100133001+66.60756243429968/60.12579266395425-84.27283380813236*59.649155445014166)+(92.56901653819604)*43.22368008105191-23.48676445733662)/65.36387155098919-16.15603648854037*35.05899408661456-68.37914421739444)))&&!(true)||!(true)||!(true)&&!(1.990037718181914>=22.154646900230944)||53.463603791331096>=((10.60737924255296-(70.59507908464052))-85.83527995341488+85.75472077985448)||!((37.1873199067831*64.32551188776475*4.0010445003156425*1.9460431864943284*41.05468817578759*81.50994313361241*37.25376505980527*8.01772014665243/6.541057866914047-69.1385030772365-((47.50490376178993))/18.66748640560123+(13.640328156420278+48.1510340650209-95.4806899129419)+58.04599697151415*21.347218439940143*85.71086058692781/46.38647654354422*85.51616698563525-99.7426640797357+95.2903536677545)<(8.231133390367473))||!(true)&&false&&true&&((99.90475705038287*93.724381005386*(40.72507569735899*79.90917371201772))*56.3195574092763*3.412237601247403-73.17875843996619-42.607450059427386-64.29860843335544*82.33604457626116-87.97501930294132+6.4337822139241+(55.18574059358603)-91.44134471875257+(39.94269163034071-73.91777430169898*(89.7810571197895*48.1776698461285)))==3.521046161274277&&false&&(73.85119770154057)!=(64.33852623734508+8.180102922207377-(81.69759011504091)*92.52657336828872/99.22933785479209)||2.263923159824488!=96.06816331889848||!(true)&&true&&!(false)||!(69.63737421730436>=((((89.92094524277556)*80.1839440314016-59.57179006722091/67.98644036047592)-86.14863793222983)))||!(false)||!(true)||!(true)||!(true)&&(((29.255859791400574*68.43352616382862)+28.691410071567102/15.705919511927114*45.08696462603821+86.63406099168317+69.01761303698538)+29.86332337824198-39.87208885314547)!=(73.99764260655586)||!(((91.40526569203192*36.188983400371946*27.304784750200962*93.92233192754586-55.92146617784013-45.41687930676856-(((5.033572210883063)+48.87377453359857*49.48225765349117/(40.06642774118373*93.812702194547)/(90.0205125202961+(54.08811410984037*(41.9138622542137*17.99056222949609*99.96524647865704)+88.60035337295365)-84.83630815943009)/95.43424622896065-93.87864447625583*94.70266034884422/34.235544578014796*15.268522994171295-83.63899014263751)*(32.135777832503386+(92.43211920764242)+27.168468658997902-83.85932232690972+50.29481217984976-77.76370399507158/(65.97822514719331-(59.11939866986259-79.92646075701865/((30.178363792077345-70.65602574150333-78.63165761436267*((0.652861923978576+65.95318900986554+99.45656517322962-99.286325314693-40.536240742053245/67.4526797813137*25.411042036379673/72.67969824894993/(75.2407011187203))-84.6438316663074*92.75617073938291-87.65174901240648-95.5954853294356+78.44009000116425-50.00797532063205/56.64104372521586+(84.93917265491307-28.38418343769383-(69.60164498624363)-43.70741248221258+83.77336190620106)-(4.86393201952946-20.24878791803697-86.46062286228985-59.51947769441881*33.87649956814914-18.458302534868633-32.214461789439085-(23.702747627064813-(56.27834173882847)+85.7172079280118*34.09193888307273)*9.78643007322695-50.972999761445024-57.4324057668823)/52.30951017648704*13.694987452146435/84.71234811290348+22.3555086518609-61.59338666351635*62.2724981907816*(71.96338101472348+1.224583311850036+82.45491371084324/39.060655561348334)*72.71884308102831*74.65837245859035-(58.69128319970181)/9.716377755905848)*2.7061400958401816*71.46944620626687*11.909633115754314-58.93388318725851))*19.55266352220557-84.6673955108152*37.50244747617616-67.24014564212676)*61.16532626543727-(91.51607268875513-81.67411456918339)/62.56580570688042)*13.062471170236911)+40.09435589935878)-66.26589220504717+66.21026098149669*38.83447407401026)/15.170053485172197-72.6116433164093/61.180678057226665+46.5579938060242+(2.6887225559876105)-47.99071385172373*51.534427332874465*35.00580476330126+34.133946730348185-61.103116045735916-65.53384159089143-18.239390121753186-26.232339205904122-14.116122177199752*(1.9450211056244449/41.881588188629884)-(18.7203940755589)+(59.1180357096302*26.393588144187984+0.7702086086031734)-5.270049691256218)<57.66145321510331)||!(true)||!(false)}", Object.class, null, null);
////			Boolean de = (Boolean) test.evaluate("${!(22.566599666231934>=11.131371330504214)}", Object.class, null, null);
//			t = System.nanoTime()-t;
//			System.out.println(de+" "+t);
			
			YExpression e = new YExpression();
		
			HashMap<String, String> mapping = new HashMap<String, String>();
			mapping.put("TcEnd", "TcEnd");
			mapping.put("TcStart", "TcStart");

			HashMap<String, Object> value = new HashMap<String, Object>();
			value.put("TcEnd", "1132980000");
			value.put("TcStart", "-31260000");
			
//			System.out.println(e.booleanEvaluation("IF[-TcStart>64800000]THEN[true]ELSE[false]", mapping, value, new LinkedList<String>()));
//			System.out.println(e.booleanEvaluation("IF[((TcEnd-TcStart)>(64800000))]THEN[true]ELSE[false]", mapping, value, new LinkedList<String>()));
//			System.out.println(fi.elaborate("IF[(((TcEnd-TcStart)>(64800000))&((TcEnd-TcStart)<=(108000000)))]THEN[((TcEnd-TcStart)-64800000)]ELSE[IF[((TcEnd-TcStart)>(108000000))]THEN[43200000]ELSE[0]]", mapping, value, new LinkedList<String>()));
//			System.out.println(fi.elaborate("IF[((TcEnd-TcStart)>(64800000))&((TcEnd-TcStart)<=(108000000))]THEN[((TcEnd-TcStart)-(64800000))]ELSE[0]", mapping, value, new LinkedList<String>()));
			System.out.println(e.booleanEvaluation("-TcStart-64800000", mapping, value, new LinkedList<String>()));
	}
	
	private Boolean solve(LinkedList s) {
		LinkedList res = new LinkedList();
		StringBuffer sb2 = new StringBuffer();
		int numInPARTA = 0;
		int numExPARTA = 0;
		int i = 0;
		Object token = null;
		if(i<s.size()) {
			token = s.get(i);
			i++;
		}
		while(i<=s.size()) {
			if(PARTA.equals(token)) {
				res.addLast(token);
				sb2.append(token);
				numInPARTA++;
				numExPARTA++;
				if(i<s.size()) token = s.get(i);
				i++;
				try {
					if(!SUB.equals(token) && token!=null ) new Double((String)token);
					if(token==null && i<s.size()) {
						Object tmpToken = s.get(i);
						if(AND.equals(tmpToken) || OR.equals(tmpToken) || NOT.equals(tmpToken)) {
							new Double((String)token);
						}
					}
					while( !(PARTC.equals(token) && numInPARTA==0) && !(AND.equals(token) || OR.equals(token) || NOT.equals(token) || MINOR.equals(token) || GREATER.equals(token) || SINGLEEQUAL.equals(token)) && i<=s.size()) {
						if(PARTA.equals(token)) {
							sb2.append(token);
							numInPARTA++;
							if(i<s.size()) token = s.get(i);
							i++;
						}else if(PARTC.equals(token)){
							sb2.append(token);
							numInPARTA--;
							if(i<s.size()) token = s.get(i); 
							i++;
						}else {
							Object tmpToken = token;
							if(i<s.size()) token = s.get(i); 
							i++;
							sb2.append(tmpToken);
						}
					}
					if(PARTC.equals(token) && i==s.size() && numInPARTA!=0){
						sb2.append(token);
						numInPARTA--;
						i++;
					}
					if(AND.equals(token) || OR.equals(token) || NOT.equals(token) || MINOR.equals(token) || GREATER.equals(token) || SINGLEEQUAL.equals(token)){
						if(numInPARTA>0) sb2.delete(0,numInPARTA);
						if(numInPARTA==0) {
							int j = 0;
							while(j<numExPARTA) {
								res.removeLast();
								j++;
							}
						}
						else {
							int j = 0;
							while(j<numExPARTA-numInPARTA) {
								res.removeLast();
								j++;
							}
						}
						numInPARTA=0;
					}else if(PARTC.equals(token)) {
						int j = 0;
						while(j<numExPARTA) {
							res.removeLast();
							j++;
						}
					}
					sb2.insert(0, PARTA);
					sb2.append(PARTC);
					st = new StringTokenizer(sb2.toString(),"(-+*/%^)",true);
//					System.out.println("SB "+sb2.toString());
					Double d = null;
					nextToken();
					nextToken();
					d = parenthesis();
					sb2.delete(0, sb2.length());
					res.addLast(d);
					numInPARTA=0;
					numExPARTA=0;
				}catch (Exception nfe) { 
					if(!PARTA.equals(token)) {
						numInPARTA=0;
						numExPARTA=0;
						sb2.delete(0, sb2.length());
					}
				}
			}else {
				boolean error = false;
				try {
					if(!SUB.equals(token) && token!=null ) {
						new Double((String)token);
					}
					if(token==null && i<s.size()) {
						Object tmpToken = s.get(i);
						if(AND.equals(tmpToken) || OR.equals(tmpToken) || NOT.equals(tmpToken)) {
							new Double((String)token);
						}
					}else {
						error = true;
						sb2.append(token);
						if(i<s.size()) token = s.get(i);
						i++;
						if(token!=null && !(SUM.equals(token) || SUB.equals(token) || MULTIPLY.equals(token) || DIVIDE.equals(token) || EXP.equals(token) || MOD.equals(token))) {
							new Double((String)token);
//						}else if(token!=null && PARTA.equals(token)) {
//							numInPARTA++;
						}
					}
					while( !(PARTC.equals(token) && numInPARTA==0) && !(AND.equals(token) || OR.equals(token) || NOT.equals(token) || MINOR.equals(token) || GREATER.equals(token) || SINGLEEQUAL.equals(token)) && i<=s.size()) {
						if(PARTA.equals(token)) {
							sb2.append(token);
							numInPARTA++;
							if(i<s.size()) token = s.get(i);
							i++;
						}else if(PARTC.equals(token)){
							sb2.append(token);
							numInPARTA--;
							if(i<s.size()) token = s.get(i); 
							i++;
						}else {
							Object tmpToken = token;
							if(i<s.size()) token = s.get(i); 
							i++;
							sb2.append(tmpToken);
						}
					}
					if(AND.equals(token) || OR.equals(token) || NOT.equals(token) || MINOR.equals(token) || GREATER.equals(token) || SINGLEEQUAL.equals(token)){
						if(numInPARTA>0) sb2.delete(0,numInPARTA);
						numInPARTA=0;
					}
					sb2.insert(0, PARTA);
					sb2.append(PARTC);
					st = new StringTokenizer(sb2.toString(),"(-+*/%^)",true);
					Double d = null;
					nextToken();
					nextToken();
					d = parenthesis();
					sb2.delete(0, sb2.length());
					res.addLast(d);
					numInPARTA=0;
				}catch (Exception nfe) { 
					if(error & sb2.length()==0) res.addLast(SUB);
					if(sb2.length()>0) {
						if(sb2.length() == 1 && sb2.toString().equals("-")) {
							int partNumInPARTA = 0;
							while( !(PARTC.equals(token) && partNumInPARTA==0) && !(AND.equals(token) || OR.equals(token) || NOT.equals(token) || MINOR.equals(token) || GREATER.equals(token) || SINGLEEQUAL.equals(token)) && i<=s.size()) {
								if(PARTA.equals(token)) {
									sb2.append(token);
									partNumInPARTA++;
									if(i<s.size()) token = s.get(i);
									i++;
								}else if(PARTC.equals(token)){
									sb2.append(token);
									partNumInPARTA--;
									if(i<s.size()) token = s.get(i); 
									i++;
									if(partNumInPARTA==0) break;
								}else {
									Object tmpToken = token;
									if(i<s.size()) token = s.get(i); 
									i++;
									sb2.append(tmpToken);
								}
							}
						}
						sb2.insert(0, PARTA);
						sb2.append(PARTC);
//						System.out.println("SB2 "+sb2.toString());
						st = new StringTokenizer(sb2.toString(),"(-+*/%^)",true);
						Double d = null;
						nextToken();
						nextToken();
						d = parenthesis();
						sb2.delete(0, sb2.length());
						res.addLast(d);
					}
					res.addLast(token);
					if(i<s.size()) token = s.get(i); 
					i++;
				}
			}
		}
//		res.addLast(token);
		
		LinkedList rimosse = removeParenthesis(res);
		rimosse = dataOperation(rimosse);
		rimosse = removeParenthesis(rimosse);
		rimosse = transformNonBoolean(rimosse);
		rimosse = removeParenthesis(rimosse);
		Boolean resB = solveBoolean(rimosse);
		
//		System.out.println("originale "+res);
//		LinkedList rimosse = removeParenthesis(res);
//		System.out.println("removeParentesis "+rimosse);
//		rimosse = dataOperation(rimosse);
//		System.out.println("dataOperation "+rimosse);
//		rimosse = removeParenthesis(rimosse);
//		System.out.println("removeParentesis "+rimosse);
//		rimosse = transformNonBoolean(rimosse);
//		System.out.println("transformNonBoolean "+rimosse);
//		rimosse = removeParenthesis(rimosse);
//		System.out.println("removeParentesis "+rimosse);
//		Boolean resB = solveBoolean(rimosse);
//		System.out.println("solveBoolean "+resB);
		return resB;
	}
	   
    /**
     * Compare two resources
     * @param resourceA String XML
     * @param operator String operator ( = ; { ; } )
     * @param resourceB String XML
     * @return return 
     */	
	private Boolean solveResource(String resourceA, String operator, String resourceB) {
		if(resourceA == null || resourceB == null) return null;
		if(operator.equals(EQUAL)) {
			StringBuffer sb = new StringBuffer();
			for(Element a : (List<Element>) JDOMUtil.stringToDocument(resourceA).getRootElement().getChildren()) {
				sb.append(JDOMUtil.elementToString(a));
			}
			String a = sb.toString();
			sb.delete(0, sb.length());
			for(Element b : (List<Element>) JDOMUtil.stringToDocument(resourceB).getRootElement().getChildren()) {
				sb.append(JDOMUtil.elementToString(b));
			}
			return a.equals(sb.toString());
		}else if(operator.equals(CONTAINS)) {
			List<Element> listA = JDOMUtil.stringToDocument(resourceA).getRootElement().getChildren();
			List<Element> listB = JDOMUtil.stringToDocument(resourceB).getRootElement().getChildren();
			if(listA.size()==1) {
				if(listB.size()==1) {
					Element a = listA.get(0);
					Element b = listB.get(0);
					if(a.getName().equals("participant")) { //a participant
						return JDOMUtil.elementToString(a).equals(JDOMUtil.elementToString(b));
					}else { // a role
						if(b.getName().equals("participant")) { // b participant
							for(Element role : (List<Element>) b.getChild("roles").getChildren()) {
								if(JDOMUtil.elementToString(a).equals(JDOMUtil.elementToString(role))) return true;
							}
							return false;
						}else { // b role
							return JDOMUtil.elementToString(a).equals(JDOMUtil.elementToString(b));
						}
					}
				}else { // B size > 1
					Element a = listA.get(0);
					if(a.getName().equals("participant")) { // a participant
						return false;
					}else { // a role
						boolean result = false;
						for(Element b : listB) {
							result = false;
							if(b.getName().equals("participant")) { // b participant
								for(Element role : (List<Element>) b.getChild("roles").getChildren()) {
									if(JDOMUtil.elementToString(a).equals(JDOMUtil.elementToString(role))) result = true;
								}
								if(!result) return false;
							}else { // b role
								result = JDOMUtil.elementToString(a).equals(JDOMUtil.elementToString(b));
							}
						}
						return result;
					}
				}
			}else {
				if(listB.size()==1) {
					for(Element a : listA) {
						Element b = listB.get(0);
						if(a.getName().equals("participant")) { //a participant
							return JDOMUtil.elementToString(a).equals(JDOMUtil.elementToString(b));
						}else { // a role
							if(b.getName().equals("participant")) { // b participant
								for(Element role : (List<Element>) b.getChild("roles").getChildren()) {
									if(JDOMUtil.elementToString(a).equals(JDOMUtil.elementToString(role))) return true;
								}
								return false;
							}else { // b role
								return JDOMUtil.elementToString(a).equals(JDOMUtil.elementToString(b));
							}
						}
					}
				}else { // B size > 1
					for(Element b : listB) {
						boolean result = false;
						for(Element a : listA) {
							if(a.getName().equals("participant")) { //a participant
								result = JDOMUtil.elementToString(a).equals(JDOMUtil.elementToString(b));
							}else { // a role
								if(b.getName().equals("participant")) { // b participant
									for(Element role : (List<Element>) b.getChild("roles").getChildren()) {
										if(JDOMUtil.elementToString(a).equals(JDOMUtil.elementToString(role))) result = true;
									}
									result = false;
								}else { // b role
									result = JDOMUtil.elementToString(a).equals(JDOMUtil.elementToString(b));
								}
							}
							if(result) break;
						}
						if(!result) return false;
					}
					return true;
				}
				return false;
			}
		}else {
			return solveResource(resourceB, CONTAINS, resourceA);
		}
	}

	/**
	 * Return the current Token
	 * @return return the current token
	 */
	private String currToken() {
		return currToken;
	}
	
	/**
	 * Check if there're more token
	 * @return return true if there're more token
	 */
	private boolean hasMoreTokens() {
		return st.hasMoreTokens();
	}
	
	/**
	 * Select the next token (that begin the current) and return it
	 * @return return the next token
	 */
	private String nextToken() {
		if(st.hasMoreTokens()) currToken = st.nextToken();
		return currToken;
	}
	
	/**
	 * Evaluate the expression
	 * @param expression expression to evaluate
	 * @param mappingName hashMap with the mapping from the variable to the key of the table value
	 * @param value hashMap with the value of the variable
	 * @param resource LinkedList contain the variable that are resource
	 * @return true if the expression is true, false if is false, null if is impossible to evaluate
	 * @exception ExpressionError
	 */
	public Boolean booleanEvaluation(String expression, HashMap<String, String> mappingName, HashMap<String, Object> value, LinkedList<String> resource) {
		StringTokenizer stTMP = new StringTokenizer(expression,"(-+*/%^&|!<=>){}",true);
		LinkedList res = new LinkedList();
		LinkedList<String> pile = new LinkedList<String>();
		LinkedList<LinkedList<String>> pile2 = new LinkedList<LinkedList<String>>();
		String previous = null;
		String s = null;
		if(mappingName == null) mappingName = new HashMap<String, String>();
		if(value == null) value = new HashMap<String, Object>();
		if(resource == null) resource = new LinkedList<String>();
		while(stTMP.hasMoreTokens()) {
			previous = s;
			s = stTMP.nextToken();
			if(PARTA.equals(s) || SUB.equals(s) || SUM.equals(s) || MULTIPLY.equals(s) || DIVIDE.equals(s) || EXP.equals(s) || MOD.equals(s) || AND.equals(s) || OR.equals(s) || NOT.equals(s) || MINOR.equals(s) || GREATER.equals(s)) {
//				if(pile2.size()>0 || pile.size()>0) throw new ExpressionError();
//				if(previous == null && (SUB.equals(s) || SUM.equals(s) || MULTIPLY.equals(s) || DIVIDE.equals(s) || EXP.equals(s))) throw new ExpressionError();
				if(SUB.equals(s)) {
					if(res.size() > 0 && res.getLast() instanceof String) {
						String last = (String) res.getLast();
						if(last.endsWith("E")) {
							res.removeLast();
							last += "-"+stTMP.nextToken();
							res.add(last);
						}else {
							res.addLast(s);
						}
					}else {
						res.addLast(s);
					}
				}else {
					res.addLast(s);
				}				
			}else if(SINGLEEQUAL.equals(s)) {
				if(pile.size()>0) pile.add(s);
				else if(pile2.size()>0) {
					LinkedList<String> l = new LinkedList<String>();
					l.add(s);
					pile2.add(l);
				}
				else {
					res.addLast(s);
				}
			}else if(CONTAINS.equals(s) || ISCONTAINED.equals(s)) {
				if(pile.size()==0 || pile2.size()>0) return null;
				pile.addLast(s);
			}else if("null".equals(s)) {
				res.addLast(null);
			}else {
				if(mappingName.containsKey(s)) {
					String mapName = mappingName.get(s);
					Object o = value.get(mapName);
					if(o == null && pile2.size()>0) {
						pile2.clear();
						res.addLast(null);
					}else if(o instanceof List) {
						LinkedList<String> oList = (LinkedList<String>)o;
						if(pile2.size()>1) {
							LinkedList<String> a = pile2.removeFirst();
							String oper = pile2.removeFirst().get(0);
							if(oper.equals(SINGLEEQUAL)) {
								pile2.removeFirst();
								oper = EQUAL;
							}
							res.addLast(compareList(a, oper, oList));
							pile2.clear();
						}else {
							if(SINGLEEQUAL.equals(res.get(res.size()-1)) && SINGLEEQUAL.equals(res.get(res.size()-2)) && res.get(res.size()-3)==null) {
								res.removeLast();
								res.removeLast();
								res.removeLast();
								res.addLast(null);
							}else pile2.addLast(oList);
						}
					}else if(resource.contains(mapName)) {
						if(o == null) {
							if(pile.size()>1) {
								String a = pile.removeFirst();
								String oper = pile.removeFirst();
								if(oper.equals(SINGLEEQUAL)) {
									pile.removeFirst();
									oper = EQUAL;
								}
								res.addLast(null);
								pile.clear();
							}else {
								pile.addLast(null);
							}
						}else if(o instanceof String) {
							String os = (String)o;
							if(pile.size()>1) {
								String a = pile.removeFirst();
								String oper = pile.removeFirst();
								if(oper.equals(SINGLEEQUAL)) {
									pile.removeFirst();
									oper = EQUAL;
								}
								res.addLast(solveResource(a, oper, os));
								pile.clear();
							}else {
								pile.addLast(os);
							}
						}
					}else {
						res.add("(");
						res.addLast(o);
						res.add(")");
					}
				}else {
					if(!s.equals(")")) res.add("(");
					res.addLast(s);
					if(!s.equals(")")) res.add(")");
				}
			}
		}
		return solve(res);
	}
	
	/**
	 * Check if the two list are equals
	 * @param a List to compare
	 * @param oper Operator (only ==)
	 * @param b List to compare
	 * @return
	 */
	private Object compareList(LinkedList<String> a, String oper, LinkedList<String> b) {
		if(a == null || b == null) return null;
		return (a.containsAll(b) && b.containsAll(a));
	}

	/**
	 * Compare two value
	 * @param a first value to compare
	 * @param b second value to compare
	 * @param mode type of comparison ( <= ; < ; == ; >= ; > ; != )
	 * @return null if a or b is null
	 */
	private Boolean compare(Comparable a, Comparable b, String mode) {
		if(a == null || b == null) return null;
		if(mode.equals(MINOR)) {
			return a.compareTo(b)<0;
		} else if(mode.equals(MINOREQUAL)) {
			return a.compareTo(b)<=0;
		} else if(mode.equals(EQUAL)) {
			return a.compareTo(b)==0;
		} else if(mode.equals(GREATEREQUAL)) {
			return a.compareTo(b)>=0;
		} else if(mode.equals(GREATER)) {
			return a.compareTo(b)>0;
		} else if(mode.equals(NOTEQUAL)) {
			return a.compareTo(b)!=0;
		}
		return false;
	}
	
	/**
	 * Solve Operation between Date using the st StringTokenizer
	 * @return Date resulting from the operation
	 */
	private Date dateParenthesis() {
		Date res = null;
		LinkedList pile = new LinkedList();
		while(!currToken().equals(PARTC)) {
			if(currToken().equals(PARTA)) {
				nextToken();
				res = dateParenthesis();
				currToken = dateFormat.format(res);
				pile.addLast(res);
			}else if(currToken().equals(SUB)) {
				Date d = (Date) pile.removeLast();
				nextToken();
				try {
					Date d2 = dateFormat.parse(currToken());
					GregorianCalendar gc = new GregorianCalendar();
					GregorianCalendar gc2 = new GregorianCalendar();
					gc.setTime(d);
					gc2.setTime(d2);
					gc.roll(Calendar.SECOND , -gc2.get(Calendar.SECOND));
					gc.roll(Calendar.MINUTE , -gc2.get(Calendar.MINUTE));
					gc.roll(Calendar.HOUR_OF_DAY , -gc2.get(Calendar.HOUR_OF_DAY));
					gc.roll(Calendar.DAY_OF_MONTH , -gc2.get(Calendar.DAY_OF_MONTH));
					gc.roll(Calendar.MONTH , -gc2.get(Calendar.MONTH));
					gc.roll(Calendar.YEAR , -gc2.get(Calendar.YEAR));
					pile.addLast(gc.getTime());
				} catch (ParseException pe) {
					GregorianCalendar gc = new GregorianCalendar();
					StringTokenizer stoken = new StringTokenizer(currToken(),"[:]",true);
					stoken.nextToken();
					Integer year = null;
					Integer month = null;
					Integer day = null;
					Integer hour = null;
					Integer min = null;
					Integer sec = null;
					String value = stoken.nextToken();
					if(value.equals(":")) year = new Integer(0);
					else {
						year = new Integer(value);
						stoken.nextToken();
					}
					value = stoken.nextToken();
					if(value.equals(":")) month = new Integer(0);
					else {
						month = new Integer(value);
						stoken.nextToken();
					}
					value = stoken.nextToken();
					if(value.equals(":")) day = new Integer(0);	
					else {
						day = new Integer(value);
						stoken.nextToken();
					}
					value = stoken.nextToken();
					if(value.equals(":")) hour = new Integer(0);
					else {
						hour = new Integer(value);
						stoken.nextToken();
					}
					value = stoken.nextToken();
					if(value.equals(":")) min = new Integer(0);
					else {
						min = new Integer(value);
						stoken.nextToken();
					}
					value = stoken.nextToken();
					if(value.equals(":")) sec = new Integer(0);
					else {
						sec = new Integer(value);
						stoken.nextToken();
					}
					gc.setTime(d);
					gc.roll(Calendar.SECOND , -sec);
					gc.roll(Calendar.MINUTE , -min);
					gc.roll(Calendar.HOUR_OF_DAY , -hour);
					gc.roll(Calendar.DAY_OF_MONTH , -day);
					gc.roll(Calendar.MONTH , -month);
					gc.roll(Calendar.YEAR , -year);
					pile.addLast(gc.getTime());
				}
				nextToken();
			}else if(currToken().equals(SUM)) {
				Date d = (Date) pile.removeLast();
				nextToken();
				try {
					Date d2 = dateFormat.parse(currToken());
					GregorianCalendar gc = new GregorianCalendar();
					GregorianCalendar gc2 = new GregorianCalendar();
					gc.setTime(d);
					gc2.setTime(d2);
					gc.roll(Calendar.MILLISECOND , gc2.get(Calendar.MILLISECOND));
					gc.roll(Calendar.SECOND , gc2.get(Calendar.SECOND));
					gc.roll(Calendar.MINUTE , gc2.get(Calendar.MINUTE));
					gc.roll(Calendar.HOUR_OF_DAY , gc2.get(Calendar.HOUR_OF_DAY));
					gc.roll(Calendar.DAY_OF_MONTH , gc2.get(Calendar.DAY_OF_MONTH));
					gc.roll(Calendar.MONTH , gc2.get(Calendar.MONTH));
					gc.roll(Calendar.YEAR , gc2.get(Calendar.YEAR));
					pile.addLast(gc.getTime());
				} catch (ParseException pe) {
					GregorianCalendar gc = new GregorianCalendar();
					StringTokenizer stoken = new StringTokenizer(currToken(),"[:]",true);
					stoken.nextToken();
					Integer year = null;
					Integer month = null;
					Integer day = null;
					Integer hour = null;
					Integer min = null;
					Integer sec = null;
					String value = stoken.nextToken();
					if(value.equals(":")) year = new Integer(0);
					else {
						year = new Integer(value);
						stoken.nextToken();
					}
					value = stoken.nextToken();
					if(value.equals(":")) month = new Integer(0);
					else {
						month = new Integer(value);
						stoken.nextToken();
					}
					value = stoken.nextToken();
					if(value.equals(":")) day = new Integer(0);	
					else {
						day = new Integer(value);
						stoken.nextToken();
					}
					value = stoken.nextToken();
					if(value.equals(":")) hour = new Integer(0);
					else {
						hour = new Integer(value);
						stoken.nextToken();
					}
					value = stoken.nextToken();
					if(value.equals(":")) min = new Integer(0);
					else {
						min = new Integer(value);
						stoken.nextToken();
					}
					value = stoken.nextToken();
					if(value.equals(":")) sec = new Integer(0);
					else {
						sec = new Integer(value);
						stoken.nextToken();
					}
					gc.setTime(d);
					gc.roll(Calendar.SECOND , sec);
					gc.roll(Calendar.MINUTE , min);
					gc.roll(Calendar.HOUR_OF_DAY , hour);
					gc.roll(Calendar.DAY_OF_MONTH , day);
					gc.roll(Calendar.MONTH , month);
					gc.roll(Calendar.YEAR , year);
					pile.addLast(gc.getTime());
				}
				nextToken();
			}else {
				try {
					pile.addLast(dateFormat.parse(currToken()));
				} catch (ParseException e) {
					e.printStackTrace();
				}
				nextToken();
			}
		}
		if(pile.size()>0) res = (Date) pile.removeFirst();
		return res;
	}

	/**
	 * Solve opetation between number using the st StringTokenizer
	 * @return the result of the operation
	 */
	private Double parenthesis() {
//		System.out.println("Call Parenthesis");
		Double res = null;
		LinkedList pile = new LinkedList();
		while(!PARTC.equals(currToken())) {
			if(PARTA.equals(currToken())) {
				nextToken();
				res = parenthesis();
				if(res != null)	currToken = res.toString();
				else currToken = null;
				pile.addLast(number());
			}else if(SUB.equals(currToken())) {
				pile.add(currToken());
				nextToken();
			}else if(SUM.equals(currToken())) {
				pile.add(currToken());
				nextToken();
			}else if(MOD.equals(currToken())) {
				pile.add(currToken());
				nextToken();
			}else if(MULTIPLY.equals(currToken())) {
				Double d = (Double) pile.removeLast();
				nextToken();
				if(PARTA.equals(currToken())) {
					nextToken();
					Double a = parenthesis();
					if(a != null && d != null) {
						res = d*a;
					}else if((a != null && a == 0.0) || (d != null && d == 0.0)) {
						res = 0.0;
					}else {
						res = null;
					}
					currToken = res.toString();
					pile.addLast(number());
				}else {
					Double a = number();
					if(a != null && d != null) {
						res = d*a;
					}else if((a != null && a == 0.0) || (res != null && d == 0.0)) {
						res = 0.0;
					}else {
						res = null;
					}
					pile.addLast(res);
				}
			}else if(DIVIDE.equals(currToken())) {
				Double d = (Double) pile.removeLast();
				nextToken();
				if(PARTA.equals(currToken())) {
					nextToken();
					Double a = parenthesis();
					if(a != null && d != null) {
						res = d/a;
					}else {
						res = null;
					}
					currToken = res.toString();
					pile.addLast(number());
				}else {
					Double a = number();
					if(a != null && d != null) {
						res = d/a;
					}else {
						res = null;
					}
					pile.addLast(res);
				}
			}else {
				if(pile.size()==1 && SUB.equals(pile.getLast())) {
					pile.removeLast();
					Double a = number();
					if(a != null) {
						pile.addLast(-a);
					}else {
						pile.addLast(null);
					}
				}else {
					Double a = number();
					if(a != null) {
						pile.addLast(a);
					}else {
						pile.addLast(null);
					}
				}
			}
		}
		if(pile.size()>0) {
			if(pile.size() == 1) {
				res = (Double) pile.removeFirst();//first;
			}else if(pile.size() == 2) {
				String first = (String) pile.removeFirst();
				if(SUB.equals(first)){
					res = (Double) pile.removeFirst();//first;
					if(res != null) res = -res;
				}else if(SUM.equals(first)) {
					res = (Double) pile.removeFirst();//first;
				}
			}else {
				res = (Double) pile.removeFirst();//first;
			}
		}
		LinkedList pile2 = new LinkedList();
//		System.out.println(pile);
		for(int i=0;i<pile.size();i+=2) {
//			System.out.println(pile.get(i));
			if(SUM.equals(pile.get(i))) {
				if(pile.get(i+1) != null && res != null) {
					res += (Double) pile.get(i+1);
				}else {
					res = null;
				}
			}else if(SUB.equals(pile.get(i))) {
				if(pile.get(i+1) != null && res != null) {
					res -= (Double) pile.get(i+1);
				}else {
					res = null;
				}
			}else if(MOD.equals(pile.get(i))) {
				pile2.add(res);
				pile2.add(pile.get(i));
				res = (Double) pile.get(i+1);
			}
		}
		pile2.add(res);
		if(pile2.size()>0) res = (Double) pile2.removeFirst();
		for(int i=0;i<pile2.size();i+=2) {
			if(MOD.equals(pile2.get(i))) {
				if(pile2.get(i+1) != null && res != null) {
					res %= (Double) pile2.get(i+1);
				}else {
					res = null;
				}
			}
		}
//		System.out.println(res);
//		System.out.println("End Parenthesis");
		return res;
	}

	/**
	 * Solve the exp of the number in st StringTokenizer
	 * @return the result of the exp
	 */
	private Double number() {
		Double res = null;
		if("null".equals(currToken()) || currToken()==null) res = null;
		else {
			try {
				res = new Double(currToken());
			}catch(NumberFormatException nfe) {
				if(currToken().endsWith("E")) {
					String last = currToken;
					last += nextToken();
					last += nextToken();
					res = new Double(last);
				}
			}
		}
		if(hasMoreTokens()) {
			nextToken();
			if(currToken().equals(EXP)){
				Double d;
				nextToken();
				if(currToken().equals(PARTA)) {
					nextToken();
					d = parenthesis();
					nextToken();
				}else {
					d = number();
				}
				if(res == null || d == null) res = null; 
				else res = Math.pow(res, d);
			}
		}
		return res;
	}
	
	/**
	 * Solve the disexpression stored in the LinkedList s
	 * @return null if is impossible to solve
	 */
//	private Boolean solve(LinkedList s) {
//		LinkedList res = new LinkedList();
//		StringBuffer sb2 = new StringBuffer();
//		int numInPARTA = 0;
//		int numExPARTA = 0;
//		int i = 0;
//		Object token = null;
//		if(i<s.size()) {
//			token = s.get(i);
//			i++;
//		}
//		while(i<s.size()) {
//			if(PARTA.equals(token)) {
//				res.addLast(token);
//				sb2.append(token);
//				numInPARTA++;
//				numExPARTA++;
//				token = s.get(i);
//				i++;
//				try {
//					if(!SUB.equals(token))new Double((String)token);
//					while( !(PARTC.equals(token) && numInPARTA==0) && !(AND.equals(token) || OR.equals(token) || NOT.equals(token) || MINOR.equals(token) || GREATER.equals(token) || SINGLEEQUAL.equals(token)) && i<s.size()) {
//						if(token.equals(PARTA)) {
//							sb2.append(token);
//							numInPARTA++;
//							token = s.get(i); 
//							i++;
//						}else if(SUB.equals(token) || SUM.equals(token) || MULTIPLY.equals(token) || DIVIDE.equals(token) || EXP.equals(token)) {
//							sb2.append(token);
//							token = s.get(i); 
//							i++;
//						}else if(PARTC.equals(token)){
//							sb2.append(token);
//							numInPARTA--;
//							token = s.get(i); 
//							i++;
//						}else {
//							sb2.append(token);
//							token = s.get(i); 
//							i++;
//						}
//					}
//					if(AND.equals(token) || OR.equals(token) || NOT.equals(token) || MINOR.equals(token) || GREATER.equals(token) || SINGLEEQUAL.equals(token)){
//						if(numInPARTA>0) sb2.delete(0,numInPARTA);
//						if(numInPARTA==0) {
//							int j = 0;
//							while(j<numExPARTA) {
//								res.removeLast();
//								j++;
//							}
//						}
//						else {
//							int j = 0;
//							while(j<numExPARTA-numInPARTA) {
//								res.removeLast();
//								j++;
//							}
//						}
//						numInPARTA=0;
//					}else if(PARTC.equals(token)) {
//						int j = 0;
//						while(j<numExPARTA) {
//							res.removeLast();
//							j++;
//						}
//					}
//					sb2.insert(0, PARTA);
//					sb2.append(PARTC);
//					System.out.println("aaa"+sb2.toString());
//					st = new StringTokenizer(sb2.toString(),"(-+*/^)",true);
//					Double d = null;
//					nextToken();
//					nextToken();
//					d = parenthesis();
//					sb2.delete(0, sb2.length());
//					res.addLast(d);
//					numInPARTA=0;
//					numExPARTA=0;
//				}catch (Exception nfe) { 
//					if(!PARTA.equals(token)) {
//						numInPARTA=0;
//						numExPARTA=0;
//						sb2.delete(0, sb2.length());
//					}
//				}
//			}else {
//				boolean error = false;
//				try {
//					if(!SUB.equals(token)) {
//						new Double((String)token);
//					}else {
//						error = true;
//						sb2.append(token);
//						token = s.get(i); 
//						i++;
//						new Double((String)token);
//					}
//					while( !(PARTC.equals(token) && numInPARTA==0) && !(AND.equals(token) || OR.equals(token) || NOT.equals(token) || MINOR.equals(token) || GREATER.equals(token) || SINGLEEQUAL.equals(token)) && i<s.size()) {
//						if(PARTA.equals(token)) {
//							sb2.append(token);
//							numInPARTA++;
//							token = s.get(i); 
//							i++;
//						}else if(SUB.equals(token) || SUM.equals(token) || MULTIPLY.equals(token) || DIVIDE.equals(token) || EXP.equals(token)) {
//							sb2.append(token);
//							token = s.get(i); 
//							i++;
//						}else if(token.equals(PARTC)){
//							sb2.append(token);
//							numInPARTA--;
//							token = s.get(i); 
//							i++;
//						}else {
//							sb2.append(token);
//							token = s.get(i); 
//							i++;
//						}
//					}
//					if(AND.equals(token) || OR.equals(token) || NOT.equals(token) || MINOR.equals(token) || GREATER.equals(token) || SINGLEEQUAL.equals(token)){
//						if(numInPARTA>0) sb2.delete(0,numInPARTA);
//						numInPARTA=0;
//					}
//					sb2.insert(0, PARTA);
//					sb2.append(PARTC);
//					System.out.println("aaa"+sb2.toString());
//					st = new StringTokenizer(sb2.toString(),"(-+*/^)",true);
//					Double d = null;
//					nextToken();
//					nextToken();
//					d = parenthesis();
//					sb2.delete(0, sb2.length());
//					res.addLast(d);
//					numInPARTA=0;
//				}catch (Exception nfe) { 
//					nfe.printStackTrace();
//					if(error) res.addLast(SUB);
//					res.addLast(token);
//					token = s.get(i); 
//					i++;
//				}
//			}
//		}
//		res.addLast(token);
//		System.out.println("originale "+res);
//		LinkedList rimosse = removeParenthesis(res);
//		System.out.println("removeParentesis "+rimosse);
//		rimosse = dataOperation(rimosse);
//		System.out.println("dataOperation "+rimosse);
//		rimosse = removeParenthesis(rimosse);
//		System.out.println("removeParentesis "+rimosse);
//		rimosse = transformNonBoolean(rimosse);
//		System.out.println("transformNonBoolean "+rimosse);
//		rimosse = removeParenthesis(rimosse);
//		System.out.println("removeParentesis "+rimosse);
//		Boolean resB = solveBoolean(rimosse);
//		System.out.println("solveBoolean "+resB);
//		return resB;
//	}
	
	
	
	/**
	 * Remove the Parenthesis in excess from the expression
	 * @param s LinkedList with the expression
	 * @return the expression
	 */
	private LinkedList removeParenthesis(LinkedList s) {
		LinkedList l = new LinkedList();
		int i = 0;
		while(i<s.size()) {
			Object token = s.get(i);
			i++;
			if(PARTC.equals(token)) {
//				System.out.println(l);
				if(PARTA.equals(l.get(l.size()-2))) {
					token = l.removeLast();
					l.removeLast();
					l.addLast(token);
				}else {
					l.addLast(token);
				}
			}else {
				l.addLast(token);
			}
		}
		return l;
	}
	
	/**
	 * Seek for Data expression inside the expression s and solve it
	 * @param s expression
	 * @return the expression with all the data expression solved
	 */
	private LinkedList dataOperation(LinkedList s) {
		LinkedList res = new LinkedList();
		StringBuffer sb2 = new StringBuffer();
		int numInPARTA = 0;
		int numExPARTA = 0;
		int i = 0;
		Object token = null;
		if(i<s.size()) {
			token = s.get(i);
			i++;
		}
		while(i<s.size()) {
			if(PARTA.equals(token)) {
				res.addLast(token);
				sb2.append(token);
				numInPARTA++;
				numExPARTA++;
				token = s.get(i);
				i++;
				try {
					dateFormat.parse((String)token);
					while( !(PARTC.equals(token) && numInPARTA==0) && !(AND.equals(token) || OR.equals(token) || NOT.equals(token) || MINOR.equals(token) || GREATER.equals(token) || SINGLEEQUAL.equals(token)) && i<s.size()) {
						if(PARTA.equals(token)) {
							sb2.append(token);
							numInPARTA++;
							token = s.get(i);
							i++;
						}else if(SUB.equals(token) || SUM.equals(token)) {
							sb2.append(token);
							token = s.get(i);
							i++;
						}else if(PARTC.equals(token)){
							sb2.append(token);
							numInPARTA--;
							token = s.get(i);
							i++;
						}else {
							sb2.append(token);
							token = s.get(i);
							i++;
						}
					}
					if(AND.equals(token) || OR.equals(token) || NOT.equals(token) || MINOR.equals(token) || GREATER.equals(token) || SINGLEEQUAL.equals(token)){
						if(numInPARTA>0) sb2.delete(0,numInPARTA);
						if(numInPARTA==0) {
							int a = 0;
							while(a<numExPARTA) {
								res.removeLast();
								a++;
							}
						}
						else {
							int a = 0;
							while(a<numExPARTA-numInPARTA) {
								res.removeLast();
								a++;
							}
						}
						numInPARTA=0;
					}else if(PARTC.equals(token)) {
						int a = 0;
						while(a<numExPARTA) {
							res.removeLast();
							a++;
						}
					}
					sb2.insert(0, PARTA);
					sb2.append(PARTC);
					st = new StringTokenizer(sb2.toString(),"(-+)",true);
					Date d = null;
					while(hasMoreTokens()) {
						nextToken();
						if(PARTA.equals(token)) {
							nextToken();
							d = dateParenthesis();
							nextToken();
						}
					}
					sb2.delete(0, sb2.length());
					res.addLast(d);
					numInPARTA=0;
					numExPARTA=0;
				}catch (Exception e) { 
					if(!PARTA.equals(token)) {
						numInPARTA=0;
						numExPARTA=0;
						sb2.delete(0, sb2.length());
					}
				}
			}else if(AND.equals(token) || OR.equals(token) || NOT.equals(token)){
				res.addLast(token);
				token = s.get(i);
				i++;
			}else {
				try {
					dateFormat.parse((String)token);
					while( !(PARTC.equals(token) && numInPARTA==0) && !(AND.equals(token) || OR.equals(token) || NOT.equals(token) || MINOR.equals(token) || GREATER.equals(token) || SINGLEEQUAL.equals(token)) && i<s.size()) {
						if(PARTA.equals(token)) {
							sb2.append(token);
							numInPARTA++;
							token = s.get(i);
							i++;
						}else if(SUB.equals(token) || SUM.equals(token)) {
							sb2.append(token);
							token = s.get(i);
							i++;
						}else if(PARTC.equals(token)){
							sb2.append(token);
							numInPARTA--;
							token = s.get(i);
							i++;
						}else {
							sb2.append(token);
							token = s.get(i);
							i++;
						}
					}
					if(AND.equals(token) || OR.equals(token) || NOT.equals(token) || MINOR.equals(token) || GREATER.equals(token) || SINGLEEQUAL.equals(token)){
						if(numInPARTA>0) sb2.delete(0,numInPARTA);
						numInPARTA=0;
					}
					sb2.insert(0, PARTA);
					sb2.append(PARTC);
					st = new StringTokenizer(sb2.toString(),"(-+)",true);
					Date d = null;
					while(hasMoreTokens()) {
						nextToken();
						if(PARTA.equals(token)) {
							nextToken();
							d = dateParenthesis();
							nextToken();
						}
					}
					sb2.delete(0, sb2.length());
					res.addLast(d);
					numInPARTA=0;
				}catch (Exception e) { 
					res.addLast(token);
					token = s.get(i);
					i++;
				}
			}
		}
		res.addLast(token);
		return res;
	}
	
	/**
	 * Solve all the final confrontation in the expression
	 * @param s expression
	 * @return expression with only boolean term and boolean operator
	 */
	private LinkedList transformNonBoolean(LinkedList s) {
		LinkedList pile = new LinkedList();
		int i = 0;
		Object token = null;
		while(i<s.size()) {
			token = s.get(i);
			i++;
			if(PARTA.equals(token)) {
				pile.addLast(token);
			}else if(AND.equals(token) || OR.equals(token) || TRUE.equals(token) || FALSE.equals(token)) {
				pile.addLast(token);
			}else if(NOT.equals(token)) {
				if(SINGLEEQUAL.equals(s.get(i))) {
					token = s.get(i);
					i++;
					Object o1 = pile.removeLast();
					token = s.get(i);
					i++;
					Object o2 = token;
					if(o1==null || o2==null) pile.addLast(null);
					else if(o1 instanceof Double && o2 instanceof Double) {
						Double d = (Double) o1;
						Double d2 = (Double) o2;
						pile.addLast(compare(d, d2, NOTEQUAL));
					} else if(o1 instanceof Date && o2 instanceof Date) {
						Date d = (Date) o1;
						Date d2 = (Date) o2;
						pile.addLast(compare(d, d2, NOTEQUAL));
					} else {
						pile.addLast(compare(""+o1, ""+o2, NOTEQUAL));
					}
				}else {
					pile.addLast(token);
				}
			}else if(MINOR.equals(token)) {
				token = s.get(i);
				i++;
				if(SINGLEEQUAL.equals(token)) {
					Object o1 = pile.removeLast();
					token = s.get(i);
					i++;
					Object o2 = token;
					if(o1==null || o2==null) pile.addLast(null);
					else if(o1 instanceof Double && o2 instanceof Double) {
						Double d = (Double) o1;
						Double d2 = (Double) o2;
						pile.addLast(compare(d, d2, MINOREQUAL));
					} else if(o1 instanceof Date && o2 instanceof Date) {
						Date d = (Date) o1;
						Date d2 = (Date) o2;
						pile.addLast(compare(d, d2, MINOREQUAL));
					} else {
						pile.addLast(compare(""+o1, ""+o2, MINOREQUAL));
					}
				}else {
					Object o1 = pile.removeLast();
					if(o1==null || token==null) pile.addLast(null);
					else if(o1 instanceof Double && token instanceof Double) {
						Double d = (Double) o1;
						Double d2 = (Double) token;
						pile.addLast(compare(d, d2, MINOR));
					} else if(o1 instanceof Date && token instanceof Date) {
						Date d = (Date) o1;
						Date d2 = (Date) token;
						pile.addLast(compare(d, d2, MINOR));
					} else {
						pile.addLast(compare(""+o1, ""+token, MINOR));
					}
				}
			}else if(SINGLEEQUAL.equals(token)) {
				Object o1 = pile.removeLast();
				token = s.get(i);
				i++;
				token = s.get(i);
				i++;
				Object o2 = token;
				if(o1==null || o2==null) pile.addLast(null);
				else if(o1 instanceof Double && o2 instanceof Double) {
					Double d = (Double) o1;
					Double d2 = (Double) o2;
					pile.addLast(compare(d, d2, EQUAL));
				} else if(o1 instanceof Date && o2 instanceof Date) {
					Date d = (Date) o1;
					Date d2 = (Date) o2;
					pile.addLast(compare(d, d2, EQUAL));
				} else {
					pile.addLast(compare(""+o1, ""+o2, EQUAL));
				}
			}else if(GREATER.equals(token)) {
				token = s.get(i);
				i++;
				if(SINGLEEQUAL.equals(token)) {
					Object o1 = pile.removeLast();
					token = s.get(i);
					i++;
					Object o2 = token;
					if(o1==null || o2==null) pile.addLast(null);
					else if(o1 instanceof Double && o2 instanceof Double) {
						Double d = (Double) o1;
						Double d2 = (Double) o2;
						pile.addLast(compare(d, d2, GREATEREQUAL));
					} else if(o1 instanceof Date && o2 instanceof Date) {
						Date d = (Date) o1;
						Date d2 = (Date) o2;
						pile.addLast(compare(d, d2, GREATEREQUAL));
					} else {
						pile.addLast(compare(""+o1, ""+o2, GREATEREQUAL));
					}
				}else {
					Object o1 = pile.removeLast();
					if(o1==null || token==null) pile.addLast(null);
					else if(o1 instanceof Double && token instanceof Double) {
						Double d = (Double) o1;
						Double d2 = (Double) token;
						pile.addLast(compare(d, d2, GREATER));
					} else if(o1 instanceof Date && token instanceof Date) {
						Date d = (Date) o1;
						Date d2 = (Date) token;
						pile.addLast(compare(d, d2, GREATER));
					} else {
						pile.addLast(compare(""+o1, ""+token, GREATER));
					}
				}
			}else if(PARTC.equals(token)) {
				pile.addLast(token);
			}else {
				pile.addLast(token);
			}
		}
		return pile;
	}
	
	/**
	 * Solve a boolean expression
	 * @param s expression
	 * @return null if the expression cannot be solved (for presence of element null)
	 */
	private Boolean solveBoolean(LinkedList s) {
		LinkedList list = new LinkedList();
		int numPARTA = 0;
		Object token = null; 
		int i = 0;
		while(i<s.size()) {
			token = s.get(i); 
			i++;
			if(PARTA.equals(token)) {
				numPARTA++;
				LinkedList sb = new LinkedList();
				while(numPARTA!=0) {
					token = s.get(i); 
					i++;
					if (PARTC.equals(token)) numPARTA--;
					else if(PARTA.equals(token)) numPARTA++;
					if(numPARTA!=0)	sb.addLast(token);
				}
				Boolean b = solveBoolean(sb);
				while(list.size()>0 && list.getLast().equals(NOT)) {
					list.removeLast();
					b = !b;
				}
				list.addLast(b);
			}else if(AND.equals(token)){
				list.addLast(token);
			}else if(OR.equals(token)){
				list.addLast(token);
			}else if(NOT.equals(token)){
				list.addLast(token);
			}else if(token instanceof String){
				Boolean b = null;
				String str = (String) token;
				if(str.equals("true")) {
					b = new Boolean(true);
				}else if(str.equals("false")) {
					b = new Boolean(false);
				}
				while(list.size()>0 && NOT.equals(list.getLast())) {
					list.removeLast();
					if(b!=null)	b = !b;
				}
				list.addLast(b);
			}else {
				Boolean b = (Boolean) token;
				while(list.size()>0 && NOT.equals(list.getLast())) {
					list.removeLast();
					if(b!=null)	b = !b;
				}
				list.addLast(b);
			}
		}
		LinkedList list2 = new LinkedList();
		i = 0;
		while(i<list.size()) {
			Object o = list.get(i);
			i++;
			if(AND.equals(o)) {
				Boolean b = (Boolean) list2.removeLast();
				o = list.get(i);
				i++;
				Boolean b2 = (Boolean) o;
				if(b!=null && b2!= null) list2.addLast(b&b2);
				else if(b2==null && b!=null && b==false) list2.add(b);
				else if(b==null && b2!=null && b2==false) list2.add(b2);
				else list2.addLast(null);
			} else if(OR.equals(o)) {
				list2.addLast(o);
			} else {
				list2.addLast(o);
			}
		}
		
		LinkedList list3 = new LinkedList();
		i = 0;
		while(i<list2.size()) {
			Object o = list2.get(i);
			i++;
			if(OR.equals(o)) {
				Boolean b = (Boolean) list3.removeLast();
				o = list2.get(i);
				i++;
				Boolean b2 = (Boolean) o;
				if(b!=null && b2!= null) b = b||b2;
				else if (b2!= null) b = b2;
				else if(b==null && b2== null) b = null; 
				list3.addLast(b);
			} else {
				list3.addLast(o);
			}
		}
		
		return (Boolean) list3.getFirst();
	}
}